---
title: A toolkit for building and using tools
author: Isabel Zimmerman | Posit, PBC
format: 
    revealjs: 
        slide-number: c/t
        css: style.css
        footer: isabelizimm.me/talk-pydata-tools
---

# Welcome! {background-image="images/base.JPG"}

::: notes
i am someone who has spent time doing data science but then transitioned into building data science tools!!

i LOVE tools.

first full time python open source hire at Posit, when it was still called RStudio.
We actually had folks building Python tools, but I was the first one dedicated SOLELY to novel Python work, particularly mlops python packages.

i am a full time software engineer building python packages as well as python experiences inside IDEs.

but my love for tools is not only contstrained to computers

but if you haven't noticed, there is a magical goose on this slide, and that is not related to my open source work

huge reader, coming to boston from a fantasy book convention in utah

i love fantasy books because of the magical items involved in the story. 

in one of my very favorite fantasy books, there's a special earring that is passed down through generations to finally defeat the bad guy at the end of the series.

something so incredibly satisfying about finding something that solves exactly the problem i have.
:::


# Why should you care about tools?

::: notes
pydata folks

i assume you're here as someone cares about or uses Python, cares about or uses data, or some venn diagram overlap of these two.
:::

## Why should you care about tools?

::: incremental
- _tool_: anything that can be used to carry out a particular function
:::

::: notes
the title of this talk is about tools.

i consider a tool to be anything i use for a specific task to get something done

this talk is about tool users and builders and the skills they share

now, these are not mutually exclusive identities.
:::

## Why should you care about _using_ tools?

- Thoughtful tool choice

```python
import pandas as pd
x = pd.DataFrame(mydata)

import polars as pl
x = pl.DataFrame(mydata)
```

::: notes
but maybe you're someone who feels more strongly that they are primarily a user of tools.

if you're in a tool -user fantasy story, the villain would be the inertia of using the same tool because you're used to it, and I'd like to convince you to consider your tools as a very important 

Is there some aspect of thoughtfully PICKING tools.

tool user, choosing the right one

pandas vs polars
::: 

## Why should you care about _building_ tools?

- Supercharge your own work
- A tool can be _anything_, including things you build for only yourself
- You might already actually be building tools!

::: notes
everyone sits somewhere on the spectrum of building and consuming tools.

maybe you don't identify immediately as a tool builder! 

i'd like to convince you otherwise.

by building a tool for yourself
better results
speed up future work

barrier to entry is way lower with AI. enables everyone to be 

as part of my book nerdiness, i rebind books as well.

i have special tools to decide the width of a book cover. these are simple pieces of carboard cut into special shapes for me to use. having tools that i have created just for me, to make my life easier, are really valuable in making certain tasks easier and more reproducible.

:::

## Why should you care about _building_ tools?

- Supercharge your own work
- A tool can be _anything_, including things you build for only yourself
- You might already actually be building tools!

```bash
gti push
```

::: notes
tools for yourself-- does not have to be anything fancy!

if you're writing code, you're building something.
a dashboard or report is a tool to make business decisions. maybe you have a function you share internally or externally to help streamline data science workflows, or something else entirely. these are all tools that you might already be making 
:::

# Making tools {background-image="images/bag.JPG"}

::: notes
When I transitioned from data scientist to tool builder, I thought I knew what mattered. I thought had already filled my bag with lots of tools!!!

I had the technical skills - I could write clean code, design APIs, optimize performance. I thought: "If it works, people will use it."

We do a fair amount of user testing at Posit where we watch someone use the tools we've built to understand how folks interact with our product.

I've watched people who are really brilliant get stuck because a button was difficult to find. or the error message was confusing


People will get stuck. Not because the code was broken - it worked as I expected it to. Tool users, and tool builders are both imperfect humans. that's beautiful! because it makes you realize that being a good tool user or builder is actually a skill you can learn and build

:::


## Skill types

::: incremental
- "hard" skills: the computer elements
    - modularity, reproducibility, flexibility
- "soft" skills: the human elements
    - knowing your user, understanding needs, delighting in the small things, explaining your work
:::


::: notes
When we think about skills on a resume, we often categorize them as hard or soft skills.

Hard skills are thing like: I can use scikit learn to build a model. I can write C++ code. 
Soft skills are things like: communication or public speaking.

Now there is a lot of baggage around the terms "hard" and "soft" skills as one side or another comes into style.
Some years, LinkedIn says soft skills are all you need, and then other years, soft skills are no longer needed.

I'm going to ask you today to put the discourse around these terms aside for a moment.
I'm not interested in trying to convince you of one or the other is better, but look at the dicotomy of different ways of working.

Really, I was thinking a lot about how to frame different ways to build tools and how to think of what is important.
That's when I realized: there are two types of skills in tool building.

Hard skills in tool building and on a resume are both technical foundations. Modularity, so your tool plays well with others. Reproducibility, so things work consistently. Structure, so your code is maintainable. These skills get your tool to work.

Soft skills - these are the human elements. Knowing your audience. Highlighting what people actually use. Letting little improvements have big impact. These skills get people to love your tool.

Here's the thing: you need both.

Today, we're going to explore both. Because the best tools - the ones that actually make data work better - nail both the technical foundation AND the human experience.

Let's start with the hard skills
:::

# A tool's hard skills (the technical side)

# 1. Modularity

## Modularity

- Building from known projects
- Allows tools to grow with users
- Extension packages <3

::: notes
-   when you build tools, build them from things that are known/scale
-   finding tools that work with what you already know


For tool builders:

Expose clear interfaces/APIs-- people can make custom extensions to customize their experience. using a tool that is already accepted by the community and customizing allows you to focus on the pieces you want

grow with users: (jules talk tomorrow morning) 2026 year of extension packages

For tool users:

Look for tools that play well with what you know

:::

##

![](images/astropy.png){fig-align="center"}


::: notes
now, this is a talk about tools, so its only fair to introduce the tool im currently working on, which is called Positron

Positron 

- IDE built specifically for data science
- VSCode fork, but includes things like variables, console, plots, etc
-   gives users the ability to grow with the tool you've built
- rodrigo's talk tomorrow morning about remote SSH and outgrowing your laptop 

-   that's nice, but important bc modularity gives users the ability to build the tool they *really* need

-   OpenVSX extensions, which means everyone's Positron looks a little different
:::


# 2. Reproducibility

::: notes
_Place these markers and teleport your work anywhere_
::: 

## Reproducibility

- Data folks know how important this is!
- Focus on the creation of reproducible artifacts

::: notes
reproducibility is something we hear about a lot for data science

it is _integral_ for trustworthy science, but there is a strong pull for exploring data in gui ways

eg, posit open source built a package called great-tables (data exploration, export, send to excel)
:::

## Reproducibility: Data Explorer

![](images/convert-to-code.gif){fig-align="center"}

::: notes
big emphasis on a first-in-class data explorer

astounding technical feat

great for quick 

able to convert filters to code at the click of a button 

really interesting application of being able to bridge the gap between gui data science and reproducibility
:::

# 3. Flexibility {background-image="images/swiss-army-wand.JPG"}

::: notes
ARTIFACT: The Swiss Army Wand (over-flexible tools)

_Has attachments for everything: stirring, cutting, measuring, divining_

- a swiss army knife is convenient, but it is not a replacement for a toolkit 
- it's helpful to have a swiss army tool for quick tasks. 
- im pro swiss army knife, but you're not going to build a house with one

so what sort of flexibility works well?
:::

## Flexibility


> _Simple is better than complex._
>_Complex is better than complicated._
> - Zen of Python


::: notes
zen of python: 

now, i know this slide says flexibility, and i really want to encourage that!

Łukasz Langa pycon keynote from 2022 talking about complex types being a code smell that your function is too complex

- as i started to build tools, i wanted everything to support everything
if i was typing an argument, i would be creating crazy unions to support pandas dataframes, polars dataframes, lists, dictionaries, tuples, _all of it_

if you have something accept complex inputs, it's going to be way harder to also support complex tasks.
:::


## Flexibility: Positron Assistant

![](images/positron-assistant.gif){fig-align="center"}

::: notes
AI tools i think have really highlighted the importance of starting with a reasonable amount of context but letting users configure more or less information.

ai often does not have the right context for good data science work

my team built positron assistant and databot in order to give things like users namespace in a jupyter notebook, data snippets, plot images, etc, in order to get the most out of your AI for data experience

happy path/normal path: give users clear overview that x, y, z is included in the prompt

clear way to remove/add context. 

BUT start from a happy path and give users
:::

# Modularity. Reproducibility. Flexibility.

::: notes
three virtues of a good tool

but there's one thing that we haven't talked about that is front of mind for everyone these days
:::

# 2025: the era of AI everything

::: notes
AI excels with well-structured, modular code (hard skills)

Your code will be read by AI assistants

strong hard skills make it easy for AI to understand your intent

AI is also very good at fixing the "hard skills"

But AI struggles without context about what users actually need (soft skills)

Building great tools requires both: technical excellence + user empathy
:::

## 2025: the era of AI everything

![](images/dont_plan_to_use_ai.png){fig-align="center"}

::: footer
https://survey.stackoverflow.co/2025/ai#developer-tools-dont-plan-to-use-ai-for-this-task
:::

::: notes
Developers show the most resistance to using AI for high-responsibility, systemic tasks like Deployment and monitoring (76% don't plan to) and Project planning (69% don't plan to).

planning is a lot of the soft skills -> things like deciding what is important, product knowledge
:::

# A tool's soft-skills (the human side)

::: notes
_The human elements that make tools delightful_
:::

# 1. Know your users

::: notes
ARTIFACT: The Empathy Mirror (user research)

Shows you the struggles of other wizards

-   understand the struggles of data scientists bc a lot of us were data scientists
:::

## Know your users

- Data scientists: experimentation, exploration, iteration
- Software engineers: driven by a certain outcome

::: notes
data work inherently looks a little different than what we would consider a software engineer to work

Data practitioners explore uncharted territories (iteration, experimentation), while software engineers build fortresses in known lands (structure, specific outcomes). You wouldn't give a cartographer a mason's tools. 

which means a tool that is built for a saoftware engineer might not be the best fit for someone who needs to do lots of exploring like a data scientist
:::

## Know your users: console

![](images/console.gif)

::: notes
one way we really wanted to show data scientists that we care is by having a permanent console in Positron. 

This is a place where you can send code to be executed; if you're not familiar with having an IPython console, you can kind of think of having a Jupyter Notebook lite.

You can use keyboard shortcuts like command or control enter to send code from a python script directly to the console, which allows you to

not only was it important to have an iterable console, we also made edits to the LSP (how your IDE is able to do things like give code completions and syntax highlighting)
:::

# 2. Emphasize discoverability {background-image="images/lantern-corner.png"}

::: notes
ARTIFACT: The Path-Illuminating Lantern (discoverability)

Shines light on the trails most traveled

honestly all other subsets of soft skills sort of fall out of the idea of knowing your users
:::

## Emphasize discoverability

-   Builders: Understand what gets used
-   Users: find the tool that works best with your usual path

::: notes
what do users care about, how can you help them find the things that are not immediately obvious

Discoverability is the eternal quest. Hidden features are like secret passages—even if they lead to treasure, they’re useless if no one finds them.

disocverability is hard! on documentation, in the actual API, in the UI

documentation helps! but it can be equally important to have self-documenting things.

information is hard to find and retain, so bringing to the front what actually gets used is really important
:::

## Quarto: simple buttons

![](images/quarto-buttons.png){fig-align="center"}

::: notes
-   things that are high impact but hard to find (render on save was deep in settings)

-   things that are constantly used

- what do users care about, how can you help them find the things that are not immediately obvious

with something like "Render on save" ; bringing it to the surface vs deep in settings makes it actually usable.

we're looking to make ui changes to how our jupyter notebooks look to ease discoverability
, and if you're interested in chatting, come say hi at the posit booth!
:::

# 3. Let little things have big impact {background-image="images/salve.png"}

::: notes
ARTIFACT: The Papercut Healing Salve (small improvements)

sometimes using a tool can feel like death by a thousand papercuts

Each tiny improvement is a drop of healing potion

i would love to do that, but how can i even find the little things?

do painful things, often

-   great way to learn to do hard things
-   great way to discover how to make things simpler
:::

## Big impact: run script

![](images/run-in-terminal.png)

::: notes
normal python file

runs in terminal like python filename.py etc
:::

## Big impact: run script

![](images/run-app.png)

::: notes
runs app according to framework like streamlit run appname
:::

# 4. Explain your work {background-image="images/crow.JPG"}

::: notes
idea of a rubber duck in programming when you try to explain thing

Perches on your shoulder, wise and patient

Explaining your work is having a helper perched on your shoulder, ready to assist or take over your tasks.

and here's the thing when you try to explain things....
:::

## Explain your work 

::: r-fit-text
> If the implementation is hard to explain, it's a bad idea. - Zen of Python
:::

::: notes
from the zen of python

helpful for handoff of work, collaborating with others, but selfishly...

having clarity on the code your are writing will supercharge your own ability to comprehend and build it.
:::

## Explain your work

![](images/bluesky.jpeg){fig-align="center"}

::: notes
now, the original context of this is literary, but i think its really a helpful framing.

if you're looking at a new package, seeing if there is not only API documentation but also examples, maybe a getting started guide

if you're adding docstrings to functions

all of this helps give your users (including yourself) better information when you're using a tool

add types to your functions.
types are not _necessary_ in Python, but if you are able to write down your intensions, it's way easier for you and others to understand intent!
:::

## Explain your work: help pane

![](images/help-pane.gif){fig-align="center"}

::: notes
the hard part is sometimes surfacing this information later.

Something we really wanted to focus on is bringing rich api documentation closer to users, so they don't have to leave the IDE to find information they need (and that probably they already have, it's just hard to find!)

we built out a help pane, that has navigation, rich highlighting, linked docs. 
support numpy, sphinx, google, and epytext style docstrings

so users can just write their function or object name with a question mark in the console and immediately see information they need. 

helps users, helps builders by narrowing the feedback loop between the two

docs are a good place to write things down, but sometimes it feels like too formal of a place to add brainstorming or half baked explanations
:::

## Explain your work (to robots)

![](images/claude-md.png){fig-align="center"}

::: notes
sometimes this doesn't seem to be a good fit for documentation, i just want to brain dump things to help me sort out my own thoughts about it.

luckily, we are now not only writing documentation for humans but also for robots, and robots are pretty good at helping connect the dots

ive also found this to be a great maintenance task to create CLAUDE.md or other documentation for LLMs to consume. 

Articulate design decisions
What's the purpose of this function?
What are the gotchas?
What's the happy path?

doesnt have to be as polished as public documentation, but still beneficial to me if i leave a project and come back to it to help get me back up to speed

> release early, release often

> share early, share often
:::

# Holistic tools

## A mission to have beautiful tools {background-image="images/tools.png"}

- Considering the input and output of your work
- Take on complexity to make a user's life easier

::: notes
ARTIFACT: The Mission Compass (Posit's philosophy)
Always points toward "beautiful tools"



:::

## Feedback loops {background-image="images/oroborus.png"}

- Use tools 
- Notice pain points 
- Share with others

::: notes
Use tools → Notice pain points → Build better tools → Share with others
This is how the ecosystem improves
You're both a consumer and contributor
Your unique perspective matters

Building tools isn't about reaching a final destination (the perfect IDE, the ultimate package). It's about the hero's journey that never ends—using tools reveals what's needed, building reveals what's possible, and sharing starts the cycle anew.
:::

# Your most powerful tool: your voice!

::: notes
Every great tool starts as someone's story of frustration and triumph.

Blog posts, conference talks, GitHub issues, linkedin posts

Sharing what works (and what doesn't) helps everyone

Your feedback makes tools better
Your tools make others' work better
This is the adventure: The continuous cycle of building and using

:::

## What makes tools stick?

- The hard skills: modularity, reproducibility, flexibility
- The soft skills: Knowing your users, emphasizing discoverability, building little things for big impact, explaining your work

## _thank you!_

Learn more about Positron @ [positron.posit.co](https://positron.posit.co)

My website @ [isabelizimm.me](https://isabelizimm.me)
